<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <link rel="stylesheet" href="http://st.pimg.net/tucs/style.css" type="text/css" />

<link rel="stylesheet" href="http://st.pimg.net/tucs/print.css" type="text/css" media="print" />

  <!-- ADD THIS -->
  <script type="text/javascript" src="http://ipv4.v6test.develooper.com/cdn/libs/jquery/1.4.2/jquery.min.js"></script>
  <script type="text/javascript" src="js/sh_main.min.js"></script>
  <script type="text/javascript" src="js/sh_perl.min.js"></script>
  <script type="text/javascript" src="js/jquery-cookie.js"></script>
  <script type="text/javascript" src="js/jquery.styleswitch.js"></script>

  <link rel="alternate" type="application/rss+xml" title="RSS 1.0" href="http://search.cpan.org/uploads.rdf" />
  <link rel="search" href="http://st.pimg.net/tucs/opensearch.xml" type="application/opensearchdescription+xml" title="SearchCPAN" />
  <title>&#73;&#79;::&#77;&#117;&#108;&#116;&#105;&#112;&#108;&#101;&#120; - search.cpan.org</title>
 <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-3528438-1']);
    _gaq.push(["_setCustomVar",2,"Distribution","IO-Multiplex",3]);
    _gaq.push(["_setCustomVar",5,"Release","IO-Multiplex-1.12",3]);
    _gaq.push(["_setCustomVar",3,"Module","IO::Multiplex",3]);
    _gaq.push(["_setCustomVar",1,"Author","MARKOV",3]);
    _gaq.push(['_trackPageview']);
  </script>
 </head>
 <body id="cpansearch">
<center><div class="logo"><a href="/"><img src="http://st.pimg.net/tucs/img/cpan_banner.png" alt="CPAN"></a></div></center>
<div class="menubar">
 <a href="/">Home</a>
&middot; <a href="/author/">Authors</a>
&middot; <a href="/recent">Recent</a>
&middot; <a href="http://log.perl.org/cpansearch/">News</a>
&middot; <a href="/mirror">Mirrors</a>
&middot; <a href="/faq.html">FAQ</a>
&middot; <a href="/feedback">Feedback</a>
</div>
<form method="get" action="/search" name="f" class="searchbox">
<input type="text" name="query" value="" size="35">
<br>in <select name="mode">
 <option value="all">All</option>
 <option value="module" >Modules</option>
 <option value="dist" >Distributions</option>
 <option value="author" >Authors</option>
</select>&nbsp;<input type="submit" value="CPAN Search">
</form>


 <a name="_top"></a>
  <div class=path>
<div id=permalink class="noprint"><a href="/perldoc?IO::Multiplex">permalink</a></div>
  <a href="/~markov/">&#77;&#97;&#114;&#107; &#79;&#118;&#101;&#114;&#109;&#101;&#101;&#114;</a> &gt;
  <a href="/~markov/IO-Multiplex-1.12/">&#73;&#79;-&#77;&#117;&#108;&#116;&#105;&#112;&#108;&#101;&#120;-1.12</a> &gt;
  &#73;&#79;::&#77;&#117;&#108;&#116;&#105;&#112;&#108;&#101;&#120;
 </div>

<div class="noprint" style="float:right;align:left;width:19ex">
<a href="http://hexten.net/cpan-faces/"><img src="http://www.gravatar.com/avatar.php?gravatar_id=18f0494979b7feef52388275080aaa34&rating=G&size=80&default=http%3A%2F%2Fst.pimg.net%2Ftucs%2Fimg%2Fwho.png" width=80 height=80 
style="float:right"
/></a>
<br style="clear:both"/>
<p style="text-align:right">Download:<br/> <a href="/CPAN/authors/id/M/MA/MARKOV/IO-Multiplex-1.12.tar.gz">IO-Multiplex-1.12.tar.gz</a></p>
<p style="text-align:right"><a href="http://deps.cpantesters.org/?module=IO::Multiplex;perl=latest">Dependencies</a></p>
<p style="text-align:right"><a href="http://www.annocpan.org/~MARKOV/IO-Multiplex-1.12/lib/IO/Multiplex.pm">Annotate this POD
</a></p>
<div class=box style='width:150px; float: right'>
<h1 class=t5>Related Modules</h1>
<div style="margin:2px">
<a href="/perldoc?Net::Server">&#78;&#101;&#116;::&#83;&#101;&#114;&#118;&#101;&#114;</a><br>
<a href="/perldoc?IO::Tee">&#73;&#79;::&#84;&#101;&#101;</a><br>
<a href="/perldoc?IO::Select">&#73;&#79;::&#83;&#101;&#108;&#101;&#99;&#116;</a><br>
<a href="/perldoc?IO::Socket">&#73;&#79;::&#83;&#111;&#99;&#107;&#101;&#116;</a><br>
<a href="/perldoc?Net::hostent">&#78;&#101;&#116;::&#104;&#111;&#115;&#116;&#101;&#110;&#116;</a><br>
<a href="/perldoc?IPC::Open3">&#73;&#80;&#67;::&#79;&#112;&#101;&#110;3</a><br>
<a href="/perldoc?IO::Handle">&#73;&#79;::&#72;&#97;&#110;&#100;&#108;&#101;</a><br>
<small>
<a href="http://perlmonks.org/?node=cpan+module+search&pivot=1&module=IO::Multiplex">more...</a><br>
By <a href="http://perlmonks.org/">perlmonks.org</a></small>
</div>
</div>

<div style="float:right">
<div class=box style='width:150px'>
<h1 class=t5>CPAN RT</h1>
<div style="margin:2px">
<table style="margin-left:auto;margin-right:auto">
<tr><td>Open&nbsp;</td><td style="text-align:right"> 0</td></tr>
<tr><td>Stalled&nbsp;</td><td style="text-align:right"> 1</td></tr>
</table>
<a href="https://rt.cpan.org/NoAuth/Bugs.html?Dist=IO-Multiplex">View Bugs</a><br/>
<a href="https://rt.cpan.org/Public/Bug/Report.html?Queue=IO-Multiplex">Report a bug</a>
</div>
</div>

</div>
</div>
  Module Version:  1.12 &nbsp;
<span class="noprint">
  <a href="/src/MARKOV/IO-Multiplex-1.12/lib/IO/Multiplex.pm">Source</a> &nbsp;
</span>
<a name="___top"></a>
<div class=pod>
<div class=toc>
<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Handling_input_on_descriptors'>Handling input on descriptors</a>
    <li class='indexItem indexItem2'><a href='#Handling_output_to_descriptors'>Handling output to descriptors</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#EXAMPLES'>EXAMPLES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Simple_Example'>Simple Example</a>
    <li class='indexItem indexItem2'><a href='#A_server_example'>A server example</a>
    <li class='indexItem indexItem2'><a href='#A_more_complex_server_example'>A more complex server example</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new'>new</a>
    <li class='indexItem indexItem2'><a href='#listen'>listen</a>
    <li class='indexItem indexItem2'><a href='#add'>add</a>
    <li class='indexItem indexItem2'><a href='#remove'>remove</a>
    <li class='indexItem indexItem2'><a href='#set_callback_object'>set_callback_object</a>
    <li class='indexItem indexItem2'><a href='#kill_output'>kill_output</a>
    <li class='indexItem indexItem2'><a href='#outbuffer'>outbuffer</a>
    <li class='indexItem indexItem2'><a href='#inbuffer'>inbuffer</a>
    <li class='indexItem indexItem2'><a href='#set_timeout'>set_timeout</a>
    <li class='indexItem indexItem2'><a href='#handles'>handles</a>
    <li class='indexItem indexItem2'><a href='#loop'>loop</a>
    <li class='indexItem indexItem2'><a href='#endloop'>endloop</a>
    <li class='indexItem indexItem2'><a href='#udp_peer'>udp_peer</a>
    <li class='indexItem indexItem2'><a href='#is_udp'>is_udp</a>
    <li class='indexItem indexItem2'><a href='#write'>write</a>
    <li class='indexItem indexItem2'><a href='#shutdown'>shutdown</a>
    <li class='indexItem indexItem2'><a href='#close'>close</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CALLBACK_INTERFACE'>CALLBACK INTERFACE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#mux_input'>mux_input</a>
    <li class='indexItem indexItem2'><a href='#mux_eof'>mux_eof</a>
    <li class='indexItem indexItem2'><a href='#mux_close'>mux_close</a>
    <li class='indexItem indexItem2'><a href='#mux_outbuffer_empty'>mux_outbuffer_empty</a>
    <li class='indexItem indexItem2'><a href='#mux_connection'>mux_connection</a>
    <li class='indexItem indexItem2'><a href='#mux_timeout'>mux_timeout</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>IO::Multiplex - Manage IO on many file handles</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<pre class="sh_perl">  use IO::Multiplex;

  my $mux = new IO::Multiplex;
  $mux-&#62;add($fh1);
  $mux-&#62;add(\*FH2);
  $mux-&#62;set_callback_object(...);
  $mux-&#62;listen($server_socket);
  $mux-&#62;loop;

  sub mux_input { ... }</pre>

<p><code>IO::Multiplex</code> is designed to take the effort out of managing multiple file handles. It is essentially a really fancy front end to the <code>select</code> system call. In addition to maintaining the <code>select</code> loop, it buffers all input and output to/from the file handles. It can also accept incoming connections on one or more listen sockets.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>It is object oriented in design, and will notify you of significant events by calling methods on an object that you supply. If you are not using objects, you can simply supply <code>__PACKAGE__</code> instead of an object reference.</p>

<p>You may have one callback object registered for each file handle, or one global one. Possibly both -- the per-file handle callback object will be used instead of the global one.</p>

<p>Each file handle may also have a timer associated with it. A callback function is called when the timer expires.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Handling_input_on_descriptors"
>Handling input on descriptors</a></h2>

<p>When input arrives on a file handle, the <code>mux_input</code> method is called on the appropriate callback object. This method is passed three arguments (in addition to the object reference itself of course):</p>

<ol>
<li>a reference to the mux,</li>

<li>A reference to the file handle, and</li>

<li>a reference to the input buffer for the file handle.</li>
</ol>

<p>The method should remove the data that it has consumed from the reference supplied. It may leave unconsumed data in the input buffer.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Handling_output_to_descriptors"
>Handling output to descriptors</a></h2>

<p>If <code>IO::Multiplex</code> did not handle output to the file handles as well as input from them, then there is a chance that the program could block while attempting to write. If you let the multiplexer buffer the output, it will write the data only when the file handle is capable of receiveing it.</p>

<p>The basic method for handing output to the multiplexer is the <code>write</code> method, which simply takes a file descriptor and the data to be written, like this:</p>

<pre class="sh_perl">    $mux-&#62;write($fh, &#34;Some data&#34;);</pre>

<p>For convenience, when the file handle is <code>add</code>ed to the multiplexer, it is tied to a special class which intercepts all attempts to write to the file handle. Thus, you can use print and printf to send output to the handle in a normal manner:</p>

<pre class="sh_perl">    printf $fh &#34;%s%d%X&#34;, $foo, $bar, $baz</pre>

<p>Unfortunately, Perl support for tied file handles is incomplete, and functions such as <code>send</code> cannot be supported.</p>

<p>Also, file handle object methods such as the <code>send</code> method of <code>IO::Socket</code> cannot be intercepted.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLES"
>EXAMPLES <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Simple_Example"
>Simple Example</a></h2>

<p>This is a simple telnet-like program, which demonstrates the concepts covered so far. It does not really work too well against a telnet server, but it does OK against the sample server presented further down.</p>

<pre class="sh_perl">    use IO::Socket;
    use IO::Multiplex;

    # Create a multiplex object
    my $mux  = new IO::Multiplex;
    # Connect to the host/port specified on the command line,
    # or localhost:23
    my $sock = new IO::Socket::INET(Proto    =&#62; &#39;tcp&#39;,
                                    PeerAddr =&#62; shift || &#39;localhost&#39;,
                                    PeerPort =&#62; shift || 23)
        or die &#34;socket: $@&#34;;

    # add the relevant file handles to the mux
    $mux-&#62;add($sock);
    $mux-&#62;add(\*STDIN);
    # We want to buffer output to the terminal.  This prevents the program
    # from blocking if the user hits CTRL-S for example.
    $mux-&#62;add(\*STDOUT);

    # We&#39;re not object oriented, so just request callbacks to the
    # current package
    $mux-&#62;set_callback_object(__PACKAGE__);

    # Enter the main mux loop.
    $mux-&#62;loop;

    # mux_input is called when input is available on one of
    # the descriptors.
    sub mux_input {
        my $package = shift;
        my $mux     = shift;
        my $fh      = shift;
        my $input   = shift;

        # Figure out whence the input came, and send it on to the
        # other place.
        if ($fh == $sock) {
            print STDOUT $$input;
        } else {
            print $sock $$input;
        }
        # Remove the input from the input buffer.
        $$input = &#39;&#39;;
    }

    # This gets called if the other end closes the connection.
    sub mux_close {
        print STDERR &#34;Connection Closed\n&#34;;
        exit;
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="A_server_example"
>A server example</a></h2>

<p>Servers are just as simple to write. We just register a listen socket with the multiplex object <code>listen</code> method. It will automatically accept connections on it and add them to its list of active file handles.</p>

<p>This example is a simple chat server.</p>

<pre class="sh_perl">    use IO::Socket;
    use IO::Multiplex;

    my $mux  = new IO::Multiplex;

    # Create a listening socket
    my $sock = new IO::Socket::INET(Proto     =&#62; &#39;tcp&#39;,
                                    LocalPort =&#62; shift || 2300,
                                    Listen    =&#62; 4)
        or die &#34;socket: $@&#34;;

    # We use the listen method instead of the add method.
    $mux-&#62;listen($sock);

    $mux-&#62;set_callback_object(__PACKAGE__);
    $mux-&#62;loop;

    sub mux_input {
        my $package = shift;
        my $mux     = shift;
        my $fh      = shift;
        my $input   = shift;

        # The handles method returns a list of references to handles which
        # we have registered, except for listen sockets.
        foreach $c ($mux-&#62;handles) {
            print $c $$input;
        }
        $$input = &#39;&#39;;
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="A_more_complex_server_example"
>A more complex server example</a></h2>

<p>Let us take a look at the beginnings of a multi-user game server. We will have a Player object for each player.</p>

<pre class="sh_perl">    # Paste the above example in here, up to but not including the
    # mux_input subroutine.

    # mux_connection is called when a new connection is accepted.
    sub mux_connection {
        my $package = shift;
        my $mux     = shift;
        my $fh      = shift;

        # Construct a new player object
        Player-&#62;new($mux, $fh);
    }

    package Player;

    my %players = ();

    sub new {
        my $package = shift;
        my $self    = bless { mux  =&#62; shift,
                              fh   =&#62; shift } =&#62; $package;

        # Register the new player object as the callback specifically for
        # this file handle.

        $self-&#62;{mux}-&#62;set_callback_object($self, $self-&#62;{fh});
        print $self-&#62;{fh}
            &#34;Greetings, Professor.  Would you like to play a game?\n&#34;;

        # Register this player object in the main list of players
        $players{$self} = $self;
        $mux-&#62;set_timeout($self-&#62;{fh}, 1);
    }

    sub players { return values %players; }

    sub mux_input {
        my $self = shift;
        shift; shift;         # These two args are boring
        my $input = shift;    # Scalar reference to the input

        # Process each line in the input, leaving partial lines
        # in the input buffer
        while ($$input =~ s/^(.*?)\n//) {
            $self-&#62;process_command($1);
        }
    }

    sub mux_close {
       my $self = shift;

       # Player disconnected;
       # [Notify other players or something...]
       delete $players{$self};
    }
    # This gets called every second to update player info, etc...
    sub mux_timeout {
        my $self = shift;
        my $mux  = shift;

        $self-&#62;heartbeat;
        $mux-&#62;set_timeout($self-&#62;{fh}, 1);
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h2>

<p>Construct a new <code>IO::Multiplex</code> object.</p>

<pre class="sh_perl">    $mux = new IO::Multiplex;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="listen"
>listen</a></h2>

<p>Add a socket to be listened on. The socket should have had the <code>bind</code> and <code>listen</code> system calls already applied to it. The <code>IO::Socket</code> module will do this for you.</p>

<pre class="sh_perl">    $socket = new IO::Socket::INET(Listen =&#62; ..., LocalAddr =&#62; ...);
    $mux-&#62;listen($socket);</pre>

<p>Connections will be automatically accepted and <code>add</code>ed to the multiplex object. <code>The mux_connection</code> callback method will also be called.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="add"
>add</a></h2>

<p>Add a file handle to the multiplexer.</p>

<pre class="sh_perl">    $mux-&#62;add($fh);</pre>

<p>As a side effect, this sets non-blocking mode on the handle, and disables STDIO buffering. It also ties it to intercept output to the handle.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="remove"
>remove</a></h2>

<p>Removes a file handle from the multiplexer. This also unties the handle. It does not currently turn STDIO buffering back on, or turn off non-blocking mode.</p>

<pre class="sh_perl">    $mux-&#62;remove($fh);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_callback_object"
>set_callback_object</a></h2>

<p>Set the object on which callbacks are made. If you are not using objects, you can specify the name of the package into which the method calls are to be made.</p>

<p>If a file handle is supplied, the callback object is specific for that handle:</p>

<pre class="sh_perl">    $mux-&#62;set_callback_object($object, $fh);</pre>

<p>Otherwise, it is considered a default callback object, and is used when events occur on a file handle that does not have its own callback object.</p>

<pre class="sh_perl">    $mux-&#62;set_callback_object(__PACKAGE__);</pre>

<p>The previously registered object (if any) is returned.</p>

<p>See also the CALLBACK INTERFACE section.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="kill_output"
>kill_output</a></h2>

<p>Remove any pending output on a file descriptor.</p>

<pre class="sh_perl">    $mux-&#62;kill_output($fh);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="outbuffer"
>outbuffer</a></h2>

<p>Return or set the output buffer for a descriptor</p>

<pre class="sh_perl">    $output = $mux-&#62;outbuffer($fh);
    $mux-&#62;outbuffer($fh, $output);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="inbuffer"
>inbuffer</a></h2>

<p>Return or set the input buffer for a descriptor</p>

<pre class="sh_perl">    $input = $mux-&#62;inbuffer($fh);
    $mux-&#62;inbuffer($fh, $input);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_timeout"
>set_timeout</a></h2>

<p>Set the timer for a file handle. The timeout value is a certain number of seconds in the future, after which the <code>mux_timeout</code> callback is called.</p>

<p>If the <code>Time::HiRes</code> module is installed, the timers may be specified in fractions of a second.</p>

<p>Timers are not reset automatically.</p>

<pre class="sh_perl">    $mux-&#62;set_timeout($fh, 23.6);</pre>

<p>Use <code>$mux-&#62;set_timeout($fh, undef)</code> to cancel a timer.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="handles"
>handles</a></h2>

<p>Returns a list of handles that the <code>IO::Multiplex</code> object knows about, excluding listen sockets.</p>

<pre class="sh_perl">    @handles = $mux-&#62;handles;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="loop"
>loop</a></h2>

<p>Enter the main loop and start processing IO events.</p>

<pre class="sh_perl">    $mux-&#62;loop;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="endloop"
>endloop</a></h2>

<p>Prematurly terminate the loop. The loop will automatically terminate when there are no remaining descriptors to be watched.</p>

<pre class="sh_perl">    $mux-&#62;endloop;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="udp_peer"
>udp_peer</a></h2>

<p>Get peer endpoint of where the last udp packet originated.</p>

<pre class="sh_perl">    $saddr = $mux-&#62;udp_peer($fh);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_udp"
>is_udp</a></h2>

<p>Sometimes UDP packets require special attention. This method will tell if a file handle is of type UDP.</p>

<pre class="sh_perl">    $is_udp = $mux-&#62;is_udp($fh);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="write"
>write</a></h2>

<p>Send output to a file handle.</p>

<pre class="sh_perl">    $mux-&#62;write($fh, &#34;&#39;ere I am, JH!\n&#34;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="shutdown"
>shutdown</a></h2>

<p>Shut down a socket for reading or writing or both. See the <code>shutdown</code> Perl documentation for further details.</p>

<p>If the shutdown is for reading, it happens immediately. However, shutdowns for writing are delayed until any pending output has been successfully written to the socket.</p>

<pre class="sh_perl">    $mux-&#62;shutdown($socket, 1);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="close"
>close</a></h2>

<p>Close a handle. Always use this method to close a handle that is being watched by the multiplexer.</p>

<pre class="sh_perl">    $mux-&#62;close($fh);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CALLBACK_INTERFACE"
>CALLBACK INTERFACE <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Callback objects should support the following interface. You do not have to provide all of these methods, just provide the ones you are interested in.</p>

<p>All methods receive a reference to the callback object (or package) as their first argument, in the traditional object oriented way. References to the <code>IO::Multiplex</code> object and the relevant file handle are also provided. This will be assumed in the method descriptions.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mux_input"
>mux_input</a></h2>

<p>Called when input is ready on a descriptor. It is passed a reference to the input buffer. It should remove any input that it has consumed, and leave any partially received data in the buffer.</p>

<pre class="sh_perl">    sub mux_input {
        my $self = shift;
        my $mux  = shift;
        my $fh   = shift;
        my $data = shift;

        # Process each line in the input, leaving partial lines
        # in the input buffer
        while ($$data =~ s/^(.*?\n)//) {
            $self-&#62;process_command($1);
        }
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mux_eof"
>mux_eof</a></h2>

<p>This is called when an end-of-file condition is present on the descriptor. This is does not nessecarily mean that the descriptor has been closed, as the other end of a socket could have used <code>shutdown</code> to close just half of the socket, leaving us free to write data back down the still open half. Like mux_input, it is also passed a reference to the input buffer. It should consume the entire buffer or else it will just be lost.</p>

<p>In this example, we send a final reply to the other end of the socket, and then shut it down for writing. Since it is also shut down for reading (implicly by the EOF condition), it will be closed once the output has been sent, after which the mux_close callback will be called.</p>

<pre class="sh_perl">    sub mux_eof {
        my $self = shift;
        my $mux  = shift;
        my $fh   = shift;

        print $fh &#34;Well, goodbye then!\n&#34;;
        $mux-&#62;shutdown($fh, 1);
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mux_close"
>mux_close</a></h2>

<p>Called when a handle has been completely closed. At the time that <code>mux_close</code> is called, the handle will have been removed from the multiplexer, and untied.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mux_outbuffer_empty"
>mux_outbuffer_empty</a></h2>

<p>Called after all pending output has been written to the file descriptor.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mux_connection"
>mux_connection</a></h2>

<p>Called upon a new connection being accepted on a listen socket.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mux_timeout"
>mux_timeout</a></h2>

<p>Called when a timer expires.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR <img alt='^' src='http://st.pimg.net/tucs/img/up.gif'></a></h1>

<p>Copyright 1999 Bruce J Keeler &#60;bruce@gridpoint.com&#62;</p>

<p>Copyright 2001-2008 Rob Brown &#60;bbb@cpan.org&#62;</p>

<p>Released under the same terms as Perl itself.</p>

<p>$Id: Multiplex.pm,v 1.36 2008/09/15 08:17:50 rob Exp $</p>

</div>


<div class="footer"><div class="cpanstats">65379 Uploads, 22082 Distributions
90829 Modules, 8784 Uploaders
</div>
<!-- ADD THIS -->
<script type="text/javascript">
    $(document).ready(function(){
        var startingStyle = $.cookie('css') ? $.cookie('css') : 'css/sh_cpan.min.css';
        $.fn.styleSwitch(startingStyle);
        $("#styleswitch").val(startingStyle);
        sh_highlightDocument();
        $("#styleswitch").bind(($.browser.msie ? "click" : "change"), function() {
            $.fn.styleSwitch($(this).val());
        });
    });
</script>
<div class="styleswitch">
    syntax highlighting:
    <select id="styleswitch">
        <option value="css/sh_none.min.css">no syntax highlighting</option>
        <option value="css/sh_acid.min.css">acid</option>
        <option value="css/sh_berries-dark.min.css">berries-dark</option>
        <option value="css/sh_berries-light.min.css">berries-light</option>
        <option value="css/sh_bipolar.min.css">bipolar</option>
        <option value="css/sh_blacknblue.min.css">blacknblue</option>
        <option value="css/sh_bright.min.css">bright</option>
        <option value="css/sh_contrast.min.css">contrast</option>
        <option value="css/sh_cpan.min.css">cpan</option>
        <option value="css/sh_darkblue.min.css">darkblue</option>
        <option value="css/sh_darkness.min.css">darkness</option>
        <option value="css/sh_desert.min.css">desert</option>
        <option value="css/sh_dull.min.css">dull</option>
        <option value="css/sh_easter.min.css">easter</option>
        <option value="css/sh_emacs.min.css">emacs</option>
        <option value="css/sh_golden.min.css">golden</option>
        <option value="css/sh_greenlcd.min.css">greenlcd</option>
        <option value="css/sh_ide-anjuta.min.css">ide-anjuta</option>
        <option value="css/sh_ide-codewarrior.min.css">ide-codewarrior</option>
        <option value="css/sh_ide-devcpp.min.css">ide-devcpp</option>
        <option value="css/sh_ide-eclipse.min.css">ide-eclipse</option>
        <option value="css/sh_ide-kdev.min.css">ide-kdev</option>
        <option value="css/sh_ide-msvcpp.min.css">ide-msvcpp</option>
        <option value="css/sh_kwrite.min.css">kwrite</option>
        <option value="css/sh_matlab.min.css">matlab</option>
        <option value="css/sh_navy.min.css">navy</option>
        <option value="css/sh_nedit.min.css">nedit</option>
        <option value="css/sh_neon.min.css">neon</option>
        <option value="css/sh_night.min.css">night</option>
        <option value="css/sh_pablo.min.css">pablo</option>
        <option value="css/sh_peachpuff.min.css">peachpuff</option>
        <option value="css/sh_print.min.css">print</option>
        <option value="css/sh_rand01.min.css">rand01</option>
        <option value="css/sh_style.min.css">style</option>
        <option value="css/sh_the.min.css">the</option>
        <option value="css/sh_typical.min.css">typical</option>
        <option value="css/sh_vampire.min.css">vampire</option>
        <option value="css/sh_vim-dark.min.css">vim-dark</option>
        <option value="css/sh_vim.min.css">vim</option>
        <option value="css/sh_whatis.min.css">whatis</option>
        <option value="css/sh_whitengrey.min.css">whitengrey</option>
        <option value="css/sh_zellner.min.css">zellner</option>
    </select>
</div>

hosted by <a href="http://www.weblocal.ca">weblocal.ca</a><br/>
<a href="http://www.weblocal.ca"><img alt="Find. Rate. Share." src="http://st.pimg.net/tucs/img/weblocal_logo.gif"></a>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript" src="http://ipv4.v6test.develooper.com/js/v1/v6test.js"></script>

<script type="text/javascript">
   // v6.target = '';
   if (!v6.target) { v6.only_once = true }
   v6.site = '7A0D89A6-2B82-11DF-B9DA-F61CBD13F020';
   v6.api_server = 'http://ipv4.v6test.develooper.com';
   try {
     v6.test();
   } catch(err) {}
</script>
<script type="text/javascript">
  $(document).ready(function(){
    $("a[href^=http:]").click(function(){
      var href = $(this).attr('href');
      var m = href.match('\/\/([^\/:]+)');
      _gaq.push(['_trackEvent','External',m[1],'Module']);
    });
    $("a[href^=/CPAN/]").click(function(){
      var href = $(this).attr('href');
      _gaq.push(['_trackEvent','Download',href,'Module']);
    });
  });
</script>
<!-- Fri Feb 25 16:56:01 2011 GMT (0.041126012802124) @cpansearch1 -->
 </body>
</html>
